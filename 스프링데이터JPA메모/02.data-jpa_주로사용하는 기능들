메소드 이름으로 쿼리 생성

	스프링 데이터 JPA는 메소드 이름을 분석해서 JPQL을 생성하고 실행

	쿼리 메소드 필터 조건
	스프링 데이터 JPA 공식 문서 참고: (https://docs.spring.io/spring-data/jpa/docs/current/
	reference/html/#jpa.query-methods.query-creation)

	스프링 데이터 JPA가 제공하는 쿼리 메소드 기능
	조회: find…By ,read…By ,query…By get…By, 
	https://docs.spring.io/spring-data/jpa/docs/current/reference/html/
	#repositories.query-methods.query-creation
	예:) findHelloBy 처럼 ...에 식별하기 위한 내용(설명)이 들어가도 된다.

	COUNT: count…By 반환타입 long

	EXISTS: exists…By 반환타입 boolean

	삭제: delete…By, remove…By 반환타입 long

	DISTINCT: findDistinct, findMemberDistinctBy

	LIMIT: findFirst3, findFirst, findTop, findTop3
	https://docs.spring.io/spring-data/jpa/docs/current/reference/html/
	#repositories.limit-query-result

	> 참고: 이 기능은 엔티티의 필드명이 변경되면 인터페이스에 정의한 메서드 이름도 꼭 함께 변경해야 한다. 
	그렇지 않으면 애플리케이션을 시작하는 시점에 오류가 발생한다.
	> 이렇게 애플리케이션 로딩 시점에 오류를 인지할 수 있는 것이 스프링 데이터 JPA의 매우 큰 장점이다.
	
	
------------------------------------------------------------------------------------------------------------------------

@Query, 리포지토리에 메소드 쿼리 정의하기

	@Query("select m from Member m where m.username = :username and m.age = :age")
  List<Member> findUser(@Param("username") String username, @Param("age") int age);
	
	jpql을 바로 사용할 수 있고 메소드명이 간략해진다. (메소드명으로 만드는 쿼리에는 조건이 많아질수록 메소드명이 길어짐)
	Repository 인터페이스에 바로 정의해서 가독성이 좋고, 쿼리에 오타가 있으면 컴파일 과정에서 오류를 잡아줄 수 있다.
	createQuery 에서 문자열에 오타가 있는것은 해당기능을 실행하기 전까지는 잡을 수 없다.
	
	*) 동적쿼리는 QuertDSL 로 할것.

@Query, 값, DTO 조회하기

	@Query("select new study.datajpa.dto.MemberDto(m.id, m.username, t.name) from Member m join m.team t")
	List<MemberDto> findMemberDto();
	
	Dto 를 만들고 Query 어노테이션에 뉴 오퍼레이션을 사용해준 후 리턴타입을 Dto로 받으면 된다.
	
파라미터 바인딩
	위치기반 바인딩은 순서가 바뀌면 결과가 바뀌기 떄문에 사용하지 않는 것이 좋다.
	
	@Query("select m from Member m where m.username in :names")
	List<Member> findByNames(@Param("names") Collection<String> names);
	in절 같은경우 컬렉션타입을 지원
	
반환타입
	컬렉션, 단건, Optional 모두 반환 가능하다 
	List<Member> findListByUsername(String username); //컬렉션
  Member findMemberByUsername(String username); //단건
  Optional<Member> findOptionalByUsername(String username); //단건 Optional
  
  List 타입으로 조회했을때 값이 없어도 null이 아니다.
  Member로 단건 조회 했을때는 값이 없으면 null 이 나온다
  
  순수 JPA는 Exception이 터진다.
   -> 데이터가 있을지 없을지 모르면 옵셔널 타입으로 반환 받는게 좋다.
   
  단건조회를 했는데 중복데이터로 두건이 조회되면 Exception이 발생한다.
  
  공식 문서에 보면 더 많은 반환타입이 있는것을 확인할 수 있다.
  https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-return-types